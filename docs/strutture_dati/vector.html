<!DOCTYPE HTML>
<html lang="in" class="gruvbox-light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Vettori - Palestra di Algoritmi</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "gruvbox-light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('gruvbox-light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="../index.html">Introduzione</a></li><li class="spacer"></li><li class="chapter-item "><a href="../nozioni/index.html"><strong aria-hidden="true">1.</strong> Nozioni</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../nozioni/modello_memoria.html"><strong aria-hidden="true">1.1.</strong> Modello della memoria</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../nozioni/memoria/stack.html"><strong aria-hidden="true">1.1.1.</strong> Stack</a></li><li class="chapter-item "><a href="../nozioni/memoria/heap.html"><strong aria-hidden="true">1.1.2.</strong> Heap</a></li></ol></li><li class="chapter-item "><a href="../nozioni/complexity.html"><strong aria-hidden="true">1.2.</strong> Complessità computazionale</a></li></ol></li><li class="chapter-item expanded "><a href="../strutture_dati/index.html"><strong aria-hidden="true">2.</strong> Strutture Dati</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../strutture_dati/vector.html" class="active"><strong aria-hidden="true">2.1.</strong> Vettori</a></li><li class="chapter-item "><div><strong aria-hidden="true">2.2.</strong> Liste</div></li><li class="chapter-item "><a href="../strutture_dati/queue.html"><strong aria-hidden="true">2.3.</strong> Code</a></li><li class="chapter-item "><a href="../strutture_dati/graph.html"><strong aria-hidden="true">2.4.</strong> Grafi</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../strutture_dati/graph/visite.html"><strong aria-hidden="true">2.4.1.</strong> Visite</a></li></ol></li><li class="chapter-item "><a href="../strutture_dati/priority_queue.html"><strong aria-hidden="true">2.5.</strong> Code di priorità</a></li><li class="chapter-item "><a href="../strutture_dati/weighted_graph.html"><strong aria-hidden="true">2.6.</strong> Grafi pesati</a></li><li class="chapter-item "><a href="../strutture_dati/stack.html"><strong aria-hidden="true">2.7.</strong> Stack</a></li><li class="chapter-item "><a href="../strutture_dati/set.html"><strong aria-hidden="true">2.8.</strong> Insiemi</a></li><li class="chapter-item "><a href="../strutture_dati/map.html"><strong aria-hidden="true">2.9.</strong> Dizionari</a></li></ol></li><li class="chapter-item "><a href="../tecniche/index.html"><strong aria-hidden="true">3.</strong> Tecniche</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../tecniche/backtracking.html"><strong aria-hidden="true">3.1.</strong> Backtracking</a></li><li class="chapter-item "><a href="../tecniche/divide_et_impera.html"><strong aria-hidden="true">3.2.</strong> Divide et Impera</a></li><li class="chapter-item "><a href="../tecniche/greedy.html"><strong aria-hidden="true">3.3.</strong> Greedy</a></li><li class="chapter-item "><div><strong aria-hidden="true">3.4.</strong> Memoization</div></li><li class="chapter-item "><div><strong aria-hidden="true">3.5.</strong> Programmazione dinamica</div></li><li class="chapter-item "><div><strong aria-hidden="true">3.6.</strong> Branch and Bound</div></li><li class="chapter-item "><div><strong aria-hidden="true">3.7.</strong> Ricerca locale</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="gruvbox-light">Gruvbox Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="gruvbox-dark">Gruvbox Dark</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Palestra di Algoritmi</h1>

                    <div class="right-buttons">
                        <a href="https://github.com/pietrocipriani/palestra-di-algoritmi" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="vettori"><a class="header" href="#vettori">Vettori</a></h1>
<p>I vettori in C++ sono dei contenitori (<em>container</em>) che si comportano in modo simile agli array, ma che hanno dimensione dinamica e possono essere ridimensionati. Per creare un vettore contenente elementi di tipo <code class="hljs language-cpp">TIPO</code> si scrive <code class="hljs language-cpp">vector&lt;TIPO&gt;</code>.</p>
<p>Memorizzano una serie di elementi uno dietro l'altro in memoria. È possibile accedere gli elementi in base all'<em>indice</em>: il numero dell'elemento (primo, secondo ecc).</p>
<p>I vector sono indicizzati da 0. Ossia il primo elemento corrisponde all'indice <code class="hljs language-cpp">0</code>, l'N-esimo elemento all'indice <code class="hljs language-cpp">N-1</code>.</p>
<h2 id="inizializzazione"><a class="header" href="#inizializzazione">Inizializzazione</a></h2>
<p>L'inizializzazione di una variabile di tipo <code class="hljs language-cpp">vector</code> si può fare nei seguenti modi (attenzione alle parentesi usate!):</p>
<ul>
<li><code class="hljs language-cpp">vector&lt;TIPO&gt; nomeVariabile</code> crea un vettore vuoto di elementi di tipo <code class="hljs language-cpp">TIPO</code> (ad es. <code class="hljs language-cpp">vector&lt;float&gt; valori</code>)</li>
<li><code class="hljs language-cpp">vector&lt;TIPO&gt; nomeVariabile(DIMENSIONE, VALORE);</code> crea un vettore con al suo interno il numero <code class="hljs language-cpp">DIMENSIONE</code> di elementi di tipo <code class="hljs language-cpp">TIPO</code> inizializzati al valore <code class="hljs language-cpp">VALORE</code> (ad es. <code class="hljs language-cpp">vector&lt;int&gt; classifica(158, 1)</code>)</li>
<li><code class="hljs language-cpp">vector&lt;TIPO&gt; nomeVariabile{ELEMENTO_1, ELEMENTO_2, ...};</code> crea un vettore di tipo <code class="hljs language-cpp">TIPO</code> contenente gli elementi <code class="hljs language-cpp">ELEMENTO_1</code>, <code class="hljs language-cpp">ELEMENTO_2</code>, ... (ad es. <code class="hljs language-cpp">vector&lt;string&gt; nomi{&quot;Pippo&quot;, &quot;Pluto&quot;, &quot;Topolino&quot;}</code>)</li>
</ul>
<h2 id="accesso"><a class="header" href="#accesso">Accesso</a></h2>
<p>Per accedere agli elementi di un <code class="hljs language-cpp">vector</code> ci sono i seguenti modi:</p>
<ul>
<li><code class="hljs language-cpp">v.at(posizione)</code> si usa per accedere all'elemento in posizione <code class="hljs language-cpp">posizione+1</code>, poichè gli indici partono da <code class="hljs language-cpp">0</code> (funziona come per gli array normali, ad es. <code class="hljs language-cpp">v.at(0)</code> restituisce il primo elemento)</li>
<li><code class="hljs language-cpp">v.front()</code> si usa per accedere al primo elemento</li>
<li><code class="hljs language-cpp">v.back()</code> si usa per accedere all'ultimo elemento</li>
</ul>
<pre><code class="language-cpp">vector&lt;int&gt; pesi{4, 7, 9, 8};
// scrive in output 4798 48
cout &lt;&lt; pesi.at(0) &lt;&lt; pesi.at(1) &lt;&lt; pesi.at(2) &lt;&lt; pesi.at(3)
	&lt;&lt; &quot; &quot; &lt;&lt; pesi.front() &lt;&lt; pesi.back() &lt;&lt; endl;
</code></pre>
<h2 id="aggiunta-di-elementi-e-ridimensionamento"><a class="header" href="#aggiunta-di-elementi-e-ridimensionamento">Aggiunta di elementi e ridimensionamento</a></h2>
<ul>
<li><code class="hljs language-cpp">v.push_back(ELEMENTO)</code> aggiunge <code class="hljs language-cpp">ELEMENTO</code> in fondo al vettore (ad es. <code class="hljs language-cpp">v.push_back(42.0)</code>)</li>
<li><code class="hljs language-cpp">v.resize(NUOVA_DIMENSIONE, VALORE)</code> ridimensiona il vettore così che abbia <code class="hljs language-cpp">NUOVA_DIMENSIONE</code> elementi. Se <code class="hljs language-cpp">NUOVA_DIMENSIONE</code> è maggiore della dimensione che aveva precedentemente, i nuovi elementi vengono inizializzati col valore <code class="hljs language-cpp">VALORE</code>. (ad es. <code class="hljs language-cpp">v.resize(1000, 0)</code>)</li>
<li><code class="hljs language-cpp">v.reserve(NUOVA_DIMENSIONE)</code> il vettore contiene ancora lo stesso numero di elementi precedenti, tuttavia ha allocato dello &quot;spazio extra&quot; per eventuali ridimensionamenti (vedasi dopo).</li>
<li><code class="hljs language-cpp">v.pop_back()</code> rimuove l'ultimo elemento del vettore</li>
<li><code class="hljs language-cpp">v.size()</code> restituisce il numero di elementi contenuti nel vettore</li>
</ul>
<pre><code class="language-cpp">vector&lt;string&gt; citta{&quot;Trento&quot;, &quot;Bolzano&quot;, &quot;Milano&quot;, &quot;Sorne&quot;};
// scrive 4 Trento Sorne
cout &lt;&lt; citta.size() &lt;&lt; &quot; &quot; &lt;&lt; citta.front() &lt;&lt; &quot; &quot; &lt;&lt; citta.back() &lt;&lt; endl;

citta.push_back(&quot;Roma&quot;); // aggiungi &quot;Roma&quot; in fondo
// scrive 5 Trento Roma
cout &lt;&lt; citta.size() &lt;&lt; &quot; &quot; &lt;&lt; citta.front() &lt;&lt; &quot; &quot; &lt;&lt; citta.back() &lt;&lt; endl;

citta.resize(2); // mantieni solo i primi 2 elementi
// scrive 2 Trento Bolzano
cout &lt;&lt; citta.size() &lt;&lt; &quot; &quot; &lt;&lt; citta.front() &lt;&lt; &quot; &quot; &lt;&lt; citta.back() &lt;&lt; endl;

citta.pop_back(); // rimuovi l'ultimo elemento, cioe' &quot;Bolzano&quot;
// scrive 1 Trento Trento
cout &lt;&lt; citta.size() &lt;&lt; &quot; &quot; &lt;&lt; citta.front() &lt;&lt; &quot; &quot; &lt;&lt; citta.back() &lt;&lt; endl;
</code></pre>
<h3 id="osservazioni"><a class="header" href="#osservazioni">Osservazioni</a></h3>
<div class="info">
La variabile di tipo <code>vector</code> salva nello stack solo le informazioni utili a conoscere la dimensione effettiva del vettore e la posizione nello heap del vettore stesso.</br>
<code>vector</code> memorizza gli elementi uno dietro l'altro in un'area contigua di memoria heap.
</div>
<p>Nella memoria heap abbiamo però detto che si può scrivere qualsiasi cosa, negli spazi vuoti.<br />
Ipotizziamo dunque di voler fare un <code class="hljs language-cpp">push_back</code> quando è già stato scritto qualcos'altro poco dopo la fine del nostro vettore: per potersi ingrandire, il <code class="hljs language-cpp">vector</code> è obbligato a dover cercare uno spazio vuoto più grande.<br />
Deve dunque <strong>copiare</strong> tutti gli elementi già presenti nella nuova area di memoria: ciò è MOLTO costoso, tuttavia il <code class="hljs language-cpp">vector</code> è stato pensato in modo da minimizzare il numero di ridimensionamenti, richiedendo un po' più di memoria.</p>
<p>Tuttavia è buona pratica, quando si conosce il numero di elementi, dire al vettore quanto spazio occupare. Abbiamo 3 modi per farlo:</p>
<ul>
<li>con il <code class="hljs language-cpp">reserve</code>: fintantochè il numero di elementi non supera la dimensione effettiva del vettore, chiamate a <code class="hljs language-cpp">push_back</code> non provocheranno nessuna copia (riallocamento).</li>
<li>Con il <code class="hljs language-cpp">resize</code>: il vettore acquisisce effettivamente una dimensione di <code class="hljs language-cpp">DIMENSIONE</code>, eventuali <code class="hljs language-cpp">push_back</code> cercheranno di incrementare <strong>ulteriormente</strong> la dimensione. In questo caso dovete limitarvi ad <strong>assegnare</strong> gli elementi già presenti!</li>
<li>In fase di dichiarazione, specificando <code class="hljs language-cpp">DIMENSIONE</code>. Valgono le stesse osservazioni di <code class="hljs language-cpp">resize</code>.</li>
</ul>
<p>Vedremo più avanti altri modi di implementare una <code class="hljs language-cpp">list</code>a di elementi in modo da ovviare alla problematica dell'allocazione (vengono introdotti altri problemi).</p>
<div class="info">
ndr: <code>list</code> in Python è un <i>array dinamico</i>: è implementato come un <code>vector</code>.
</div>
<h2 id="scorrere-un-vettore"><a class="header" href="#scorrere-un-vettore">Scorrere un vettore</a></h2>
<p>Per scorrere tutti gli elementi di un <code class="hljs language-cpp">vector</code> si può usare un normale <code class="hljs language-cpp">for</code> come si farebbe per gli array normali. La variabile <code class="hljs language-cpp">i</code> del ciclo va da <code class="hljs language-cpp">0</code> a <code class="hljs language-cpp">numeri.size()</code> (non compreso) e quindi tocca, in ordine, tutti gli elementi di <code class="hljs language-cpp">numeri</code>.</p>
<pre><code class="language-cpp">vector&lt;float&gt; numeri{3.14, 2.78, 1+2.1, 3*1.12};
for(int i = 0; i &lt; numeri.size(); ++i) {
	cout &lt;&lt; &quot;In posizione &quot; &lt;&lt; i &lt;&lt; &quot; c'e' il numero &quot; &lt;&lt; numeri.at(i) &lt;&lt; endl;
}
</code></pre>
<p>Vi è un altro modo di iterare gli elementi dei vari contenitori: </p>
<pre><code class="language-cpp">vector&lt;float&gt; numeri{3.14, 2.78, 1+2.1, 3*1.12};

// si legge come: &quot;per ogni `numero` in `numeri`&quot;
for (float numero : numeri) {
    // facciamo qualcosa con `numero`.
}
</code></pre>
<p>Tale modalità di iterazione potrà essere più efficiente per certi tipi di collezioni che vedremo più avanti.<br />
Tuttavia non permette di sapere a che elemento siamo arrivati (salvo contare manualmente in una variabile esterna).<br />
In questo caso è possibile fare la copia di <code class="hljs language-cpp">numero</code> senza troppi problemi, dato che è un <code class="hljs language-cpp">float</code>.<br />
Nel caso <code class="hljs language-cpp">numero</code> fosse stato di un tipo molto più &quot;grosso&quot; è sicuramente meglio predere un <strong>riferimento</strong> (<code class="hljs language-cpp">TIPO&amp; numero</code>).</p>
<h2 id="passare-un-vettore-ad-una-funzione"><a class="header" href="#passare-un-vettore-ad-una-funzione">Passare un vettore ad una funzione</a></h2>
<p>Ovviamente i <code class="hljs language-cpp">vector</code> sono dei tipi come altri, quindi possono essere passati come parametro di una funzione senza problemi.<br />
Però, quando un parametro viene passato ad una funzione, esso viene copiato per fare in modo che la funzione non possa modificare la copia originale di quella variabile ma riceva una copia tutta per sè.<br />
Poichè i <code class="hljs language-cpp">vector</code> possono essere costosi da copiare, conviene prevenirlo mettendo una <code class="hljs language-cpp">&amp;</code> dopo il tipo del parametro della funzione, per dire al compilatore di passare tale parametro <em>per reference</em>, ovvero non copiarlo.<br />
Però passare parametri alle funzioni senza copiarli può permettere alle funzioni di modificare le variabili che passiamo loro; se vogliamo evitare ciò (ad esempio perchè una funzione che scrive a schermo non deve modificare il contenuto del vettore che gli passiamo) possiamo mettere un <code class="hljs language-cpp">const</code> prima del tipo del parametro.</p>
<pre><code class="language-cpp">// quando questa funzione viene chiamata, il vettore passato
// al posto di `v` viene copiato (operazione costosa)
void printVettore(vector&lt;int&gt; v) {
	for (int i = 0; i &lt; v.size(); ++i) {
		cout &lt;&lt; v &lt;&lt; &quot; &quot;;
	}
	cout &lt;&lt; endl;
}

// quando questa funzione viene chiamata, il vettore passato al posto
// di `v` non viene copiato ma la funzione ne ha accesso diretto
void printVettoreOttimizzato(const vector&lt;int&gt;&amp; v) {
	v.push_back(5); // errore! `v` e' dichiarato const, quindi non puo' essere modificato 
	for (int i = 0; i &lt; v.size(); ++i) {
		cout &lt;&lt; v &lt;&lt; &quot; &quot;; // tuttavia possiamo leggerlo liberamente.
	}
	cout &lt;&lt; endl;
}

// questa funzione aggiunge un elemento sia ad `a` che a `b`, ma solo
// la modifica a b viene recepita dal chiamante, perche' a e'
// stato copiato prima di venir modificato, b invece no.
void modificaSecondoVettore(vector&lt;int&gt; a, vector&lt;int&gt;&amp; b) {
	a.push_back(-1);
	b.push_back(-1);
	cout &lt;&lt; &quot;Vettore a in modificaSecondoVettore: &quot;;    
	printVettoreOttimizzato(a);
	cout &lt;&lt; &quot;Vettore b in modificaSecondoVettore: &quot;;
	printVettoreOttimizzato(b);
}

int main() {
	vector&lt;int&gt; a{0,1,2,3};
	vector&lt;int&gt; b{9,8,7};

	cout &lt;&lt; &quot;Vettore a all'inizio: &quot;;
	printVettore(a); // a viene copiato, costoso!
	cout &lt;&lt; &quot;Vettore b all'inizio: &quot;;
	printVettoreOttimizzato(b); // b non viene copiato

	modificaSecondoVettore(a, b);

	cout &lt;&lt; &quot;Vettore a nel main: &quot;;
	printVettoreOttimizzato(a); // uguale all' a originale
	cout &lt;&lt; &quot;Vettore b nel main: &quot;;
	printVettoreOttimizzato(b); // modificato
}
</code></pre>
<h2 id="esercizi"><a class="header" href="#esercizi">Esercizi</a></h2>
<ul>
<li>Scrivi un programma che chiede all'utente dei numeri finchè non viene inserito -1 e poi li scrive nell'ordine opposto in cui sono stati inseriti (attenzione agli indici!).</li>
<li>Scrivi un programma che chiede all'utente dei numeri finchè non viene inserito -1, e ad ogni numero <code class="hljs language-cpp">i</code> che viene fornito dall'utente, scriva in output l<code class="hljs language-cpp">i-1</code>-esimo numero che l'utente ha inserito (oppure -1 se tale numero non esiste). Ad esempio, se inserisco, in ordine, <code class="hljs language-cpp">5 0 1 4 3</code>, il programma dovrebbe scrivermi, in ordine, <code class="hljs language-cpp">-1 5 0 -1 4</code>.</li>
<li>Scrivi una funzione che, preso come parametro un vettore di numeri (attenzione a fare in modo che questo vettore non venga copiato), ne calcola il minimo e il massimo e li ritorna in un <code class="hljs language-cpp">pair&lt;&gt;</code>. La <em>signature</em> della funzione sarebbe quindi qualcosa come <code class="hljs language-cpp">pair&lt;int, int&gt; f(vector<int>&amp; v)</code>.</li>
<li>(difficile) Scrivi una funzione che calcola la lunghezza di una linea spezzata a partire dal vettore di punti che la compongono. Si possono fare infatti anche dei <code class="hljs language-cpp">vector</code> di <code class="hljs language-cpp">pair</code> in questo modo: <code class="hljs language-cpp">vector&lt;pair&lt;float, float&gt;&gt;</code>.</li>
</ul>
<h2 id="problemi"><a class="header" href="#problemi">Problemi</a></h2>
<p>Questi problemi si possono probabilmente risolvere anche senza usare <code class="hljs language-cpp">vector</code>, ma cercate di usarlo per allenamento!</p>
<ul>
<li>Kattis: <a href="https://open.kattis.com/problems/peasoup">peasoup</a>, <a href="https://open.kattis.com/contests/wg4y5t/problems/missingnumbers">missingnumbers</a>, <a href="https://open.kattis.com/problems/eventplanning">eventplanning</a>, <a href="https://open.kattis.com/problems/basicprogramming1">basicprogramming1</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../strutture_dati/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../strutture_dati/queue.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../strutture_dati/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../strutture_dati/queue.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
